<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="http://localhost:4000/style/main.css"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>C++ 11 Job System | Fling Engine</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="C++ 11 Job System" />
<meta name="author" content="Ben Hoffman" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Over the course of the last semester I have been working on a team to create a multi-threaded engine using DirectX 12, with a focus on data oriented design. One of my tasks throughout development was to create a Job System that we can use to parallelize tasks like physics calculations. This system came with a couple of constraints:" />
<meta property="og:description" content="Over the course of the last semester I have been working on a team to create a multi-threaded engine using DirectX 12, with a focus on data oriented design. One of my tasks throughout development was to create a Job System that we can use to parallelize tasks like physics calculations. This system came with a couple of constraints:" />
<link rel="canonical" href="http://localhost:4000/cpp/general/2018/11/12/cpp-job-system.html" />
<meta property="og:url" content="http://localhost:4000/cpp/general/2018/11/12/cpp-job-system.html" />
<meta property="og:site_name" content="Fling Engine" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-12T21:16:02-05:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/cpp/general/2018/11/12/cpp-job-system.html"},"@type":"BlogPosting","dateModified":"2018-11-12T21:16:02-05:00","url":"http://localhost:4000/cpp/general/2018/11/12/cpp-job-system.html","author":{"@type":"Person","name":"Ben Hoffman"},"headline":"C++ 11 Job System","description":"Over the course of the last semester I have been working on a team to create a multi-threaded engine using DirectX 12, with a focus on data oriented design. One of my tasks throughout development was to create a Job System that we can use to parallelize tasks like physics calculations. This system came with a couple of constraints:","datePublished":"2018-11-12T21:16:02-05:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!--<link rel="stylesheet" href="/assets/main.css"> --><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Fling Engine" />


</head>
<body>

    <div id="mainContent">

      <div class="container borderXwidth">
  <a href="http://localhost:4000/index.html#mainContent">HOME</a>
</div>

        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">C++ 11 Job System</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-11-12T21:16:02-05:00" itemprop="datePublished">Nov 12, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Ben Hoffman</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Over the course of the last semester I have been working on a team to
create a multi-threaded engine using DirectX 12, with a focus on data
oriented design. One of my tasks throughout development was to create a
Job System that we can use to parallelize tasks like physics calculations. This
system came with a couple of constraints:</p>

<ul>
  <li>There needs to be a way to track the completion of tasks, to avoid data races
when sending things like position data of an entity to the GPU.</li>
  <li>The Job System needs to have a simple interface that takes a <code class="highlighter-rouge">void *</code> as
an argument, and so that it would match some of the same data layout of an SDK that
is being used with the project.</li>
  <li>It must be portable code that will work in both a Windows and UNIX based
environment.</li>
</ul>

<p>During my research of how to go about building a job system, I came across
<a href="https://www.youtube.com/watch?v=8AjRD6mU96s&amp;t=1532s">this</a> CppCon talk by
Jason Jurecka. During his talk, he mentions a Task Manager where he uses
<code class="highlighter-rouge">std::future</code> and <code class="highlighter-rouge">std::promise</code> to keep track of tasks. This seemed like a good
starting concept for me to base my own job system on.</p>

<h1 id="implementation">Implementation</h1>
<p><em>* Check out the full project on <a href="https://github.com/engine-buddies/light-vox-engine/">GitHub</a></em></p>

<p>First of all, I needed to define what a <em>job</em> was going to be in this system.
A job is basically a function pointer, but it needs to be generic so that any
class can use the job system. To solve this problem I took a polymorphic
approach where an <code class="highlighter-rouge">IJob</code> is an abstract definition of the job type.</p>

<pre><code class="language-C++">struct IJob {
    virtual ~IJob() {}
    virtual bool invoke( void* args, int aIndex ) = 0;
};
</code></pre>

<p>This allowed me to have two child classes, one for member functions and one for
non-member functions.</p>

<pre><code class="language-C++">/** Defintion for non-member functions */
struct JobFunc : IJob {
    JobFunc( void( *aFunc_ptr )( void*, int ) )
    : func_ptr( aFunc_ptr ) { }

    virtual bool invoke( void* args, int aIndex ) override {
        func_ptr( args, aIndex );
        return true;
    }

    /** The function pointer for this job to invoke */
    void( *func_ptr )( void*, int );
};

/** Defintion for member functions */
template &lt;class T&gt;
struct JobMemberFunc : IJob {
    JobMemberFunc( T* aParent, void ( T::*f )( void*, int ) )
    : parentObj ( aParent ), func_ptr( f ) { }

    virtual bool invoke( void* args, int aIndex ) override {
        if ( !parentObj ) { return false; }

        ( parentObj-&gt;*func_ptr )( args, aIndex );
        return true;
    }

    /** the object to invoke the function pointer on */
    T* parentObj;

    /** The function pointer to call when we invoke this function */
    void ( T::*func_ptr )( void*, int );
};
</code></pre>

<p>Now that I have a definition of what a <code class="highlighter-rouge">Job</code> actually is, I want to be able to
store a queue of them for the worker threads to take tasks from. To do this, I
defined at <code class="highlighter-rouge">CpuJob</code> struct:</p>

<pre><code class="language-C">struct CpuJob {
    IJob* jobPtr = nullptr;
    void* jobArgs = nullptr;
    int index = 0;
};
</code></pre>

<p>I do this so that I can easily store both the function pointer to the job, and
the arguments that need to be passed in. This does come add a limitation to the
system that if you were to pass in an argument that was allocated on the stack,
then it could cause problems when actually invoking the job.</p>

<p>With the <code class="highlighter-rouge">CpuJob</code> definition, I can now store a queue of <code class="highlighter-rouge">CpuJob</code>’s and make a
simple interface for adding jobs. For the interface that I provide to my users I
just created a simple template <code class="highlighter-rouge">AddJob</code> function that adds to the job queue.
In order to eliminate the most contention, the actual job queue should be a
lockless queue. Check out <a href="https://www.velanstudios.com/blog/posts/our-first-open-source-release.html">Velan Studios’ lock free implementation</a>
if you are interested in that.</p>

<p>Now that there is a base for a simple job system, I needed a way to actually
track the completion of the Jobs. The reason that we may want this is because if
we have something like physics calculations, they need to happen before we can
send that data to the GPU in order to avoid race conditions.</p>

<p>To accomplish this, I used <code class="highlighter-rouge">std::future</code> and <code class="highlighter-rouge">std::promise</code>, which is not something
that I have seen a lot of other Job System’s use to control their flow of jobs.</p>

<p>The workflow of doing this is simple, you just need to create a promise
and store it’s future in a variable. Then, you can pass a pointer to that
promise and have your job call the <code class="highlighter-rouge">set_value()</code> function when it is complete,
effectively signaling to the dependent thread that the job is done.</p>

<p>Here is an example:</p>

<pre><code class="language-C++">void Solver::Update () {
    std::promise&lt;void&gt; aPromise;
    std::future&lt;void&gt; aFuture = aPromise.get_future();
    a_argument-&gt;jobPromise = &amp;aPromise;     // a_argument is defined in this class
    jobManager-&gt;AddJob( this, &amp;Physics::Solver::AccumlateForces, ( void* ) ( a_argument ), 0 );
    aFuture.wait(); // This is a blocking function that will wait for that promise
                    // to be fulfilled
}
</code></pre>
<p>Where inside the job function:</p>

<pre><code class="language-C++">void Solver::AccumlateForces( void* args, int index ) {
    PhysicsArguments* myArgs = static_cast&lt; PhysicsArguments* &gt;( args );
    // Some kind of work for this thread...
    myArgs-&gt;jobPromise-&gt;set_value();    // Signal that this job is done
}
</code></pre>

<p>As you can see, I am just using a <code class="highlighter-rouge">future</code> of <code class="highlighter-rouge">void</code> type, so it is just acting
as a kind of “flag”. Another clear use case for these is to actually get return
values from they with the <code class="highlighter-rouge">.get()</code> method on a <code class="highlighter-rouge">future</code> object.</p>

<p>One thing to watch out for here is the size of <code class="highlighter-rouge">std::future</code> and <code class="highlighter-rouge">std::promise</code>.
It shouldn’t really be a huge problem, but it is something to watch out for. On
a 64-bit Ubuntu system:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Size of std::future&lt;void&gt;  : 16
Size of std::promise&lt;void&gt; : 24
</code></pre></div></div>

<p>They are not huge objects but it is certainly something to be aware of if they
are being created frequently.</p>

<h2 id="conclusion">Conclusion</h2>

<p>By using the more modern C++ 11 features of <code class="highlighter-rouge">std::future</code> and <code class="highlighter-rouge">std::promise</code>,
we can create a Job System that can easily make tracking jobs easier
and more explicit to the users of that system.</p>

<p>One thing that I do want to add to this system is an abstraction layer where
the user can just make some kind of “Job Sequence”, making it even easier and
more explicit of what operations are happening first. At this moment, the system
assumes a level of knowledge about how <code class="highlighter-rouge">future</code>’s and <code class="highlighter-rouge">promise</code>’s work.</p>

<p>I would love feedback about this system, or any thoughts on potential improvements.</p>

<p>See the full project on <a href="https://github.com/engine-buddies/light-vox-engine/">GitHub</a>!</p>

<h3 id="c-11-features">C++ 11 Features</h3>

<p><a href="https://en.cppreference.com/w/cpp/thread/future"><code class="highlighter-rouge">std::future</code></a></p>

<p><a href="https://en.cppreference.com/w/cpp/thread/promise"><code class="highlighter-rouge">std::promise</code></a></p>

  </div><a class="u-url" href="/cpp/general/2018/11/12/cpp-job-system.html" hidden></a>
</article>


    </div> <!-- End Main content -->
<footer>

  <a href="https://github.com/flingengine" target="_blank"><img src="http://localhost:4000\media\GitHub-Mark-32px.png" lat="GitHub Logo"/></a>
  <a href="https://twitter.com/benjafriend" target="_blank"><img src="http://localhost:4000\media\twitter_logo.png" lat="Twitter Logo"/></a>

  <p>&#169; Copyright Ben Hoffman 2019</p>
    
</footer>
</body>

</html>
